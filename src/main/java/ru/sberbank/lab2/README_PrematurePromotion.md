Результаты:
1) Без явных ограничений по -Xmx и при отключённой адаптивности, JVM выберет некий стартовый размер хипа 
и структуру поколений по умолчанию. Новое поколение относительно мало, объекты быстро проходят Minor GC 
и при выживании переходят в старшее поколение. Однако, если старшее поколение ещё далеко от заполнения 
(благодаря изначально достаточному объёму или медленному накоплению), Full GC может долго не наступать. 
Частые Minor GC происходят быстро, поскольку молодое поколение невелико, 
но оно опустошается без существенного давления на старшее поколение, 
отсюда и редкое выполнение Full GC
2) Здесь явно задан небольшой размер хипа (24мб) с очень большим новым поколением (16мб). 
Объекты быстро аллоцируются в молодом поколении, и при Minor GC многие сразу продвигаются в старшее.
Старшему остаётся всего около 8мб и оно быстро заполняется. Это приводит к частым Full GC. 
Частая полная сборка - следствие ограниченности старшего поколения и низкого порога перехода объектов из молодого в старое
3) Увеличенный общий размер кучи (64мб) и половина её под молодое поколение (32мб) снижают частоту Full GC. 
Теперь старшее поколение примерно вдвое больше, чем во втором случае, что позволяет ему вместить больше объектов, 
прежде чем потребуется полная сборка. Minor GC всё ещё будут происходить по мере наполнения 32мб молодого поколения, 
но Full GC будут реже, поскольку при том же уровне продвижения объектов старшее поколение наполняется медленнее 
благодаря увеличенному общему размеру.
4) Ограничение на количество чанков (1000 вместо 10000) меняет нагрузку. 
Объекты реже накапливаются в большом количестве. За счёт более частого вызова processBatch, 
накопленный пул освобождается, что снижает количество долго живущих объектов, достигающих старшего поколения. 
В результате, несмотря на такие же параметры кучи, старшее поколение заполняется медленнее. 
Это уменьшает частоту Full GC по сравнению со сценарием 2. Minor GC по-прежнему часты.
5) -XX:+NeverTenure на java8 работает? Она же с Java 9... Чисто сценарий как в 3... 
У нас большой хип (64мб), половина под молодое поколение, и объекты при достаточной выживаемости всё же оказываются 
в старшем поколении, которое периодически заполняется и вызывает Full GC
